[
	{
		"asm": "HALT",
		"byte": "0x00",
		"syntax": "HALT",
		"implemented": true,
		"description": "Halts execution."
	},

	{
		"asm": "ZERO",
		"byte": "0x10",
		"syntax": "ZERO ra",
		"implemented": true,
		"description": "Multiplies ra with 0."
	},

	{
		"asm": "ADD",
		"byte": "0x11",
		"syntax": "ADD ra rb rc",
		"implemented": false,
		"description": "ra = rb + rc"
	},

	{
		"asm": "SUB",
		"byte": "0x12",
		"syntax": "SUB ra rb rc",
		"implemented": false,
		"description": "ra = rb - rc"
	},

	{
		"asm": "MUL",
		"byte": "0x13",
		"syntax": "MUL ra rb rc",
		"implemented": false,
		"description": "ra = rb * rc"
	},

	{
		"asm": "DIV",
		"byte": "0x14",
		"syntax": "DIV ra rb rc",
		"implemented": false,
		"description": "ra = rb / rc"
	},

	{
		"asm": "MOD",
		"byte": "0x15",
		"syntax": "MOD ra rb rc",
		"implemented": false,
		"description": "ra = rb mod rc"
	},

	{
		"asm": "POW",
		"byte": "0x16",
		"syntax": "POW ra rb rc",
		"implemented": false,
		"description": "ra = rb^rc"
	},

	{
		"asm": "ADDU",
		"byte": "0x19",
		"syntax": "ADDU ra rb rc",
		"implemented": true,
		"description": "ra = rb + rc"
	},

	{
		"asm": "SUBU",
		"byte": "0x1A",
		"syntax": "SUBU ra rb rc",
		"implemented": true,
		"description": "ra = rb - rc"
	},

	{
		"asm": "MULU",
		"byte": "0x1B",
		"syntax": "MULU ra rb rc",
		"implemented": true,
		"description": "ra = rb * rc"
	},

	{
		"asm": "DIVU",
		"byte": "0x1C",
		"syntax": "DIVU ra rb rc",
		"implemented": true,
		"description": "ra = rb / rc"
	},

	{
		"asm": "MODU",
		"byte": "0x1D",
		"syntax": "MODU ra rb rc",
		"implemented": true,
		"description": "ra = rb mod rc"
	},

	{
		"asm": "POWU",
		"byte": "0x1E",
		"syntax": "POWU ra rb rc",
		"implemented": true,
		"description": "ra = rb<sup>rc</sup>"
	},

	{
		"asm": "AND",
		"byte": "0x31",
		"syntax": "AND ra rb rc",
		"implemented": true,
		"description": "ra = rb & rc"
	},

	{
		"asm": "OR",
		"byte": "0x32",
		"syntax": "OR ra rb rc",
		"implemented": true,
		"description": "ra = rb | rc"
	},

	{
		"asm": "XOR",
		"byte": "0x33",
		"syntax": "OR ra rb rc",
		"implemented": true,
		"description": "ra = rb ^ rc"
	},

	{
		"asm": "INV",
		"byte": "0x34",
		"syntax": "INV ra rb rc",
		"implemented": true,
		"description": "ra = rb with bits inverted"
	},

	{
		"asm": "LSH",
		"byte": "0x35",
		"syntax": "INV ra rb rc",
		"implemented": true,
		"description": "ra = rb << rc"
	},

	{
		"asm": "RSH",
		"byte": "0x36",
		"syntax": "INV ra rb rc",
		"implemented": true,
		"description": "ra = rb >> rc"
	},

	{
		"asm": "LDW",
		"byte": "0x51",
		"syntax": "LDW ra rb rc",
		"implemented": false,
		"description": "ra = M[rb+rc] (word starting at that address)"
	},

	{
		"asm": "LDB",
		"byte": "0x52",
		"syntax": "LDB ra rb rc",
		"implemented": false,
		"description": "ra = first byte of M[rb+rc]"
	},

	{
		"asm": "LDI",
		"byte": "0x53",
		"syntax": "LDI ra immediate",
		"implemented": true,
		"description": "ra = immediate"
	},

	{
		"asm": "STW",
		"byte": "0x53",
		"syntax": "STW ra rb rc",
		"implemented": false,
		"description": "M[rb+rc] = ra"
	},

	{
		"asm": "STB",
		"byte": "0x53",
		"syntax": "STW ra rb rc",
		"implemented": false,
		"description": "M[rb+rc] = lower byte of ra"
	},
]

00 - Halt execution
01 -
0A - Next Register set
0B - Previous register set
0C - Clone register (from one set to another)

56 - Store
57 - Store byte

61 - uncoditional jump
62 - jump if equals
63 - jump if not equals
64 - jump if less than
65 - jump if less than or equals

68 - branch
69 - branch if equals
6A - branch if not equals
6B - branch if less than
6C - branch if less than or equals

81 - Print register a as integer
82 - Print register a as char
